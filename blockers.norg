
* Nightowl.nvim
  A project roadmap for [nightowl.nvim]{https://github.com/bbjornstad/nightowl.nvim}

** Critical Blockers
   The following subsections indicate tracked issues and their possible steps
   towards resolution. There is not a particular order to them, outside of the
   order induced by needing certain functionality at certain times for other
   reasons.
*** neorg
    - Neorg is complaining all the time, specifically about not being able to
      find the right neorg modules component to load.
    -- This seems to be a problem that can strike if the external modules
       haven't been appropriately updated to match with neorg version 6.0
    -- The easiest solution, and currently implemented solution, is to simply
       not include the offending external modules.
*** edgy.nvim
    - Edgy is causing problems, once again related to the supposed-to-be-disabled
      neo-tree...
    -- this is intensely frustrating as I am doing everything I can to keep the
       tree plugin out of my configuration. But it just keeps finding its way
       into the problems.

*** nvim-cmp
    The mappings are not quite right...in particular I want to stop accepting
    on <CR> and instead keep the return-key behavior the same as it was
    previously. This is probably just an apparent mismatch between one of the
    various sources that is probably trying to capture the animals for
    sequestration and eventually fostering or other reasonable method of
    handling.
    ---

** Unimplemented Features
*** neorg
*** general
*** lazyflex.nvim
    One of the more promising looking plugins that I have found recently,
    lazyflex allows the definition of groups of plugins to be managed more
    cleanly and conveniently by providing an extra method of enabling/disabling
    plugins from a separate collection (e.g. LazyVim components and extras).
    - ( ) Fully map the remaining plugins to consitutent "components", or
          high-level groupings of plugins that are desinged to facilitate
          particular behavior
    - ( ) correctly format the two files that are needed for this; consult with
          lazyflex.nvim documentation for more info

*** dashboard (alpha.nvim, dashboard.nvim, mini.starter, etc).
    This, for some reason, is just not working the correct way that it is
    supposed to. We really want veil.nvim to be complete as a plugin, and not
    in a halfway state with the animation API and surrounding functions.

*** AI Assistants and Code Editing Improvements
    This is the section devoted specifically to the part of my nvim
    configuration which handles all interaction with external LLM or
    chatgpt-like interfaces.
    -----

**** A Definitive Specification, Perhaps?
     Let the following items determine the precise "ideal" definition of how
     plugins should be specified with regard to their import/setup-order
     adjusting properties that are available in lazy.nvim.

     ~ A plugin P1 is a dependency of another plugin P2 when the operations of
     P1 are required in the execution of the specification of the operations
     of P2. In this case P1 should be marked in the dependencies field of P2.
     ~~
     @code lua
     {
       "user2/plugin2",
       dependencies = {
         "user1/plugin1"
       }
     }
     @end
     ~ A plugin that is loaded lazily cannot be used directly in the
       specification of another plugin without an additional function guard
       across the targeted property, even if the dependent plugin is specified
       as a dependency. This is most commonly encountered with the `keys` field
       and using a bare `require('plugin').function` as the action item.
     ~ A plugin's internal operations do not have to rely on another plugin
       for the latter to be a dependency of the first. This is to say that
       there are two main scenarios when a plugin should be marked as a
       dependency: when that plugin is specified by the author of the dependent
       plugin as being a dependency, and when the user uses the functionality
       of the dependency plugin in the lazy specification of the dependent
       plugin regardless of whether or not the plugin author specifies the
       dependent plugin as being so.
     ~ The `keys` and `opts` fields are the two main fields for which a
       "functionalization" is necessary. These fields are set up prior to the
       corresponding setup call for the plugin, and so all dependent calls
       within either the `keys` or the `opts` field must resolve at the time
       that the  `config` fields are required, hence the noted behavior here.
     ~ Occasionally, there is need to set up a certain parameter or separate
       behavior within the configuration of a particular plugin. Examples of
       this include things like setting up an autocommand, defining a user
       command, etc. In these cases, there are generally two possibilities:
       either using the `init` field, or using the `config` field. There are
       some subtle distinctions between the two.
     ~~ The `init` field is called first, and all of the init fields
        represented in the plugin specification are executed together before
        other setup. If this timing is required for the particular loading
        configuration of the target plugin, then the `init` field is your best
        option. However, this is not frequently the case.
     ~~ The `config` field is called at the time when an action or
        functionality provided by the plugin is required, or if the importation
        is otherwise signaled because of lazy.nvim plugin specification fields
        (e.g. `event`, `ft`, `cmd`, `dependencies`, each of which specifies a
        different reason for loading a plugin). If this timing seems more
        optimal for behavioral augmentations at the time of loading, then you
        should probably use the `config` field unless doing so would overwrite
        another more necessary `config` present in another spec loation.
     ~~ Lastly, when lazy loading using lazy.nvim, note that the `init` field
        is called regardless of the lazy-loading-status of the plugin, while
        the `config` field is not. This implies that if you wish to include
        certain setup behavior regardless of whether other plugin functionality
        is loaded lazily, then you will need to use the `init` field, and
        further understand that the available operations and manipulations may
        be somewhat limited. This is, from what I can tell, a major reason why
        it seems most vim variable definitions or assignments occur in the
        `init` field instead of a different more deferred option
     ~~ Note that `init` as a LazyPluginSpec field can be defined only as a
        function accepting at most the LazyPlugin item that corresponds to the
        `init` target. This is in contrast to the `keys`, `opts`, and
        especially `config` fields, which all accept an additional `opts` field
        representing the "current state" of the cobbling process that creates
        the final internal representation for the LazyPluginSpec. Hence, it is
        not possible to modify the `opts` field or other corresponding items
        using the `init` field, that must be done in a field which can accept
        the target property as an argument to the property's defining function.
        Like how `opts` can be given as `fun(LazyPlugin, opts)`

        ===

* Random Notes: Nightowl.nvim
  This is a section of the document that can hold some random notes related to
  the implementation of all of the stuff that is listed in the preceding
  section.
  ---
